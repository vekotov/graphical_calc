#ifndef SRC_RPN_H_
#define SRC_RPN_H_

#include "structs.h"

/**************************************************************************************************
 *  Функция перевода ввода пользователя в обратную польскую нотацию
 *      при помощи алгоритма Дейкстры
 *
 *          Аргументы:
 *  char *input - ввод пользователя (инфиксная нотация)
 *
 *          Возврат:
 *  Queue *result - очередь операций записанная с помощью обратной польской нотации
**************************************************************************************************/
Queue *input_to_rpn(char *input);

/**************************************************************************************************
 *  Функция разбиения ввода пользователя на лексемы
 *
 *          Аргументы:
 *  char *input - ввод пользователя (инфиксная нотация)
 *
 *          Возврат:
 *  Queue *result - очередь из лексем (числа и операции), записанная в том же порядке,
 *      как и в вводе пользователя
**************************************************************************************************/
Queue *input_to_tokens(char *input);

/**************************************************************************************************
 *  Функция получения приоритета операции
 *
 *          Аргументы:
 *  int op - ID операции (см. defines.h)
 *
 *          Возврат:
 *  int priority - её приоритет для сравнения с другими операциями
**************************************************************************************************/
int get_priority(int op);

/**************************************************************************************************
 *  Функция потребления одного выражения (операция или значение) в польскую нотацию с помощью
 *      алгоритма Дейкстры
 *
 *          Аргументы:
 *  int op - ID операции (см. defines.h)
 *  double value - значение операции (в случае если операция это просто число)
 *  Stack *stack - стэк для временного хранения операций
 *  Queue *exit - выходная очередь
 *  int i - номер шага (количество потребленных выражений до этого)
**************************************************************************************************/
void consume(int op, double value, Stack *stack, Queue *exit, int i);

/**************************************************************************************************
 *  Функция возращающая является ли операция числом (т.е. переменной или просто числом)
 *
 *          Аргументы:
 *  int op - ID операции (см. defines.h)
 * 
 *          Возврат:
 *  int result - 1, если является, 0 в ином случае
**************************************************************************************************/
int is_num_op(int op);

/**************************************************************************************************
 *  Функция возращающая является ли операция закрывающей скобкой
 *
 *          Аргументы:
 *  int op - ID операции (см. defines.h)
 * 
 *          Возврат:
 *  int result - 1, если является, 0 в ином случае
**************************************************************************************************/
int is_close_bracket(int op);

/**************************************************************************************************
 *  Функция возращающая является ли операция префиксным оператором
 *      (например sin/cos или унарным минусом)
 *
 *          Аргументы:
 *  int op - ID операции (см. defines.h)
 * 
 *          Возврат:
 *  int result - 1, если является, 0 в ином случае
**************************************************************************************************/
int is_prefix_op(int op);

/**************************************************************************************************
 *  Функция возращающая является ли операция бинарной
 *      (например +, *, бинарный минус)
 *
 *          Аргументы:
 *  int op - ID операции (см. defines.h)
 * 
 *          Возврат:
 *  int result - 1, если является, 0 в ином случае
**************************************************************************************************/
int is_binary_op(int op);

/**************************************************************************************************
 *  Функция обрабатывающая закрывающую скобку по польской нотации
 *      (выталкивает всё до открывающей скобки из стэка в конечную очередь)
 *
 *          Аргументы:
 *  Stack *stack - временный стэк для алгоритма Дейкстры
 *  Queue *exit - конечная очередь
 *  int i - номер шага (количество уже обработанных выражений)
**************************************************************************************************/
void close_bracket(Stack *stack, Queue *exit, int i);

/**************************************************************************************************
 *  Функция обрабатывающая появление новой бинарной операции.
 *  Выталкивает из стэка в конечную очередь все операции с таким же или большим приоритетом,
 *      если они находятся в голове стэка.
 *
 *          Аргументы:
 *  int op - ID операции (см. defines.h)
 *  Stack *stack - временный стэк для алгоритма Дейкстры
 *  Queue *exit - конечная очередь
**************************************************************************************************/
void restack_binary_op(int op, Stack *stack, Queue *exit);

/**************************************************************************************************
 *  Функция переводящая операцию из символа ('+', '-' и тд.) в числовой эквивалент (см. defines.h)
 *
 *          Аргументы:
 *  char op - символ операции ('+', '-' и тд.)
 *          Возврат:
 *  int op - ID операции (см. defines.h), -1 если операция не найдена
**************************************************************************************************/
int one_char_op_to_int(char op);

/**************************************************************************************************
 *  Функция переводящая операцию из нескольких символов (sin, cos) в числовой эквивалент
 *      (см. defines.h)
 *
 *          Аргументы:
 *  char *input - строка, в начале которой находится оператор (нуль-терминатор не обязателен)
 *          Возврат:
 *  int op - ID операции (см. defines.h), -1 если операция не найдена
**************************************************************************************************/
int check_multichar_ops(char *input);

/**************************************************************************************************
 *  Функция проверяющая, что в начале строки находится 'sin('
 *
 *          Аргументы:
 *  char *input - строка, в начале которой находится оператор (нуль-терминатор не обязателен)
 *          Возврат:
 *  int result - 1, если в начале строки есть 'sin(', иначе 0
**************************************************************************************************/
int check_sin(char *input);

/**************************************************************************************************
 *  Функция проверяющая, что в начале строки находится 'cos('
 *
 *          Аргументы:
 *  char *input - строка, в начале которой находится оператор (нуль-терминатор не обязателен)
 *          Возврат:
 *  int result - 1, если в начале строки есть 'cos(', иначе 0
**************************************************************************************************/
int check_cos(char *input);

/**************************************************************************************************
 *  Функция проверяющая, что в начале строки находится 'tg('
 *
 *          Аргументы:
 *  char *input - строка, в начале которой находится оператор (нуль-терминатор не обязателен)
 *          Возврат:
 *  int result - 1, если в начале строки есть 'tg(', иначе 0
**************************************************************************************************/
int check_tan(char *input);

/**************************************************************************************************
 *  Функция проверяющая, что в начале строки находится 'ctg('
 *
 *          Аргументы:
 *  char *input - строка, в начале которой находится оператор (нуль-терминатор не обязателен)
 *          Возврат:
 *  int result - 1, если в начале строки есть 'ctg(', иначе 0
**************************************************************************************************/
int check_ctan(char *input);

/**************************************************************************************************
 *  Функция проверяющая, что в начале строки находится 'sqrt('
 *
 *          Аргументы:
 *  char *input - строка, в начале которой находится оператор (нуль-терминатор не обязателен)
 *          Возврат:
 *  int result - 1, если в начале строки есть 'sqrt(', иначе 0
**************************************************************************************************/
int check_sqrt(char *input);

/**************************************************************************************************
 *  Функция проверяющая, что в начале строки находится 'ln('
 *
 *          Аргументы:
 *  char *input - строка, в начале которой находится оператор (нуль-терминатор не обязателен)
 *          Возврат:
 *  int result - 1, если в начале строки есть 'ln(', иначе 0
**************************************************************************************************/
int check_log(char *input);

/**************************************************************************************************
 *  Функция выдающая длину оператора в символах через его ID
 *      (только для мультисимвольных операторов)
 *
 *          Аргументы:
 *  int op - ID оператора (см. defines.h)
 *          Возврат:
 *  int result - 1, если в начале строки есть 'sin(', иначе 0
**************************************************************************************************/
int lenof(int op);

/**************************************************************************************************
 *  Функция выдающая длину числа в начале строки
 *
 *          Аргументы:
 *  char *input - строка в которой в начале находится число (возможно не целое)
 *          Возврат:
 *  int result - количество символов которые занимает число
**************************************************************************************************/
int skip_number(char *input);

/**************************************************************************************************
 *  Функция парсящая одну лексему (число или иной оператор)
 *
 *          Аргументы:
 *  char *input - строка в которой находятся лексемы
 *  int i - смещение по строке в символах
 *  int *is_unary - указатель на переменную, храняющую является ли ближайший минус унарным
 *  Queue *q - указатель на выходную очередь, в которую будут записаны лексемы
 *          Возврат:
 *  int i - новое смещение по строке в символах (с утчетом прочтенной лексемы)
**************************************************************************************************/
int parse_step(char *input, int i, int *is_unary, Queue *q);

#endif  // SRC_RPN_H_
